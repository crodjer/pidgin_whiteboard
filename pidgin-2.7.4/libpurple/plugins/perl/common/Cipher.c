/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of Cipher.xs. Do not edit this file, edit Cipher.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Cipher.xs"
#include "module.h"

#line 13 "Cipher.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 56 "Cipher.c"

XS(XS_Purple__Cipher_get_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher_get_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cipher");
    {
	Purple__Cipher	cipher = purple_perl_ref_object(ST(0));
	const gchar *	RETVAL;
	dXSTARG;

	RETVAL = purple_cipher_get_name(cipher);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher_get_capabilities); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher_get_capabilities)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cipher");
    {
	Purple__Cipher	cipher = purple_perl_ref_object(ST(0));
	guint	RETVAL;
	dXSTARG;

	RETVAL = purple_cipher_get_capabilities(cipher);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher_digest_region); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher_digest_region)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "name, data_sv, in_len, digest");
    {
	const gchar *	name = (const gchar *)SvPV_nolen(ST(0));
	SV *	data_sv = ST(1);
	size_t	in_len = (size_t)SvUV(ST(2));
	SV *	digest = ST(3);
#line 64 "Cipher.xs"
		gboolean ret;
		guchar *buff = NULL;
		guchar *data = NULL;
		size_t data_len;
#line 122 "Cipher.c"
	size_t	RETVAL;
	dXSTARG;
#line 69 "Cipher.xs"
		data = (guchar *)SvPV(data_sv, data_len);
		SvUPGRADE(digest, SVt_PV);
		buff = (guchar *)SvGROW(digest, in_len);
		ret = purple_cipher_digest_region(name, data, data_len, in_len, buff, &RETVAL);
		if(!ret) {
			SvSetSV_nosteal(digest, &PL_sv_undef);
			XSRETURN_UNDEF;
		}
		SvCUR_set(digest, RETVAL);
		SvPOK_only(digest);
#line 136 "Cipher.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher_http_digest_calculate_response); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher_http_digest_calculate_response)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 9)
       croak_xs_usage(cv,  "algorithm, method, digest_uri, qop, entity, nonce, nonce_count, client_nonce, session_key");
    {
	const gchar*	algorithm = (const gchar *)SvPV_nolen(ST(0));
	const gchar*	method = (const gchar *)SvPV_nolen(ST(1));
	const gchar*	digest_uri = (const gchar *)SvPV_nolen(ST(2));
	const gchar*	qop = (const gchar *)SvPV_nolen(ST(3));
	const gchar*	entity = (const gchar *)SvPV_nolen(ST(4));
	const gchar*	nonce = (const gchar *)SvPV_nolen(ST(5));
	const gchar*	nonce_count = (const gchar *)SvPV_nolen(ST(6));
	const gchar*	client_nonce = (const gchar *)SvPV_nolen(ST(7));
	const gchar*	session_key = (const gchar *)SvPV_nolen(ST(8));
	gchar_own *	RETVAL;

	RETVAL = purple_cipher_http_digest_calculate_response(algorithm, method, digest_uri, qop, entity, nonce, nonce_count, client_nonce, session_key);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);

    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher_http_digest_calculate_session_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher_http_digest_calculate_session_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "algorithm, username, realm, password, nonce, client_nonce");
    {
	const gchar*	algorithm = (const gchar *)SvPV_nolen(ST(0));
	const gchar*	username = (const gchar *)SvPV_nolen(ST(1));
	const gchar*	realm = (const gchar *)SvPV_nolen(ST(2));
	const gchar*	password = (const gchar *)SvPV_nolen(ST(3));
	const gchar*	nonce = (const gchar *)SvPV_nolen(ST(4));
	const gchar*	client_nonce = (const gchar *)SvPV_nolen(ST(5));
	gchar_own *	RETVAL;

	RETVAL = purple_cipher_http_digest_calculate_session_key(algorithm, username, realm, password, nonce, client_nonce);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);

    }
    XSRETURN(1);
}


XS(XS_Purple__Ciphers_find_cipher); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Ciphers_find_cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	gchar *	name = (gchar *)SvPV_nolen(ST(0));
	Purple__Cipher	RETVAL;

	RETVAL = purple_ciphers_find_cipher(name);
	ST(0) = purple_perl_bless_object(RETVAL, "Purple::Cipher");

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__Ciphers_register_cipher); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Ciphers_register_cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "name, ops");
    {
	gchar *	name = (gchar *)SvPV_nolen(ST(0));
	Purple__Cipher__Ops	ops = purple_perl_ref_object(ST(1));
	Purple__Cipher	RETVAL;

	RETVAL = purple_ciphers_register_cipher(name, ops);
	ST(0) = purple_perl_bless_object(RETVAL, "Purple::Cipher");

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__Ciphers_unregister_cipher); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Ciphers_unregister_cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "cipher");
    {
	Purple__Cipher	cipher = purple_perl_ref_object(ST(0));
	gboolean	RETVAL;

	RETVAL = purple_ciphers_unregister_cipher(cipher);
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__Ciphers_get_ciphers); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Ciphers_get_ciphers)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 122 "Cipher.xs"
	GList *l;
#line 296 "Cipher.c"
#line 124 "Cipher.xs"
	for (l = purple_ciphers_get_ciphers(); l != NULL; l = l->next) {
		XPUSHs(sv_2mortal(purple_perl_bless_object(l->data, "Purple::Cipher")));
	}
#line 301 "Cipher.c"
	PUTBACK;
	return;
    }
}


XS(XS_Purple__Ciphers_get_handle); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Ciphers_get_handle)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	Purple__Handle	RETVAL;

	RETVAL = purple_ciphers_get_handle();
	ST(0) = purple_perl_bless_object(RETVAL, "Purple::Handle");

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_set_option); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_set_option)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "context, name, value");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	gchar *	name = (gchar *)SvPV_nolen(ST(1));
	gpointer	value = purple_perl_ref_object(ST(2));

	purple_cipher_context_set_option(context, name, value);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_get_option); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_get_option)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "context, name");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	gchar *	name = (gchar *)SvPV_nolen(ST(1));
	gpointer	RETVAL;

	RETVAL = purple_cipher_context_get_option(context, name);
	ST(0) = purple_perl_bless_object(RETVAL, "gpointer");

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "klass, cipher, extra = NULL");
    {
	Purple__Cipher	cipher = purple_perl_ref_object(ST(1));
	void *	extra;
	Purple__Cipher__Context	RETVAL;

	if (items < 3)
	    extra = NULL;
	else {
	    extra = INT2PTR(void *,SvIV(ST(2)));
	}

	RETVAL = purple_cipher_context_new(cipher, extra);
	ST(0) = purple_perl_bless_object(RETVAL, "Purple::Cipher::Context");

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_new_by_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_new_by_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "klass, name, extra = NULL");
    {
	gchar *	name = (gchar *)SvPV_nolen(ST(1));
	void *	extra;
	Purple__Cipher__Context	RETVAL;

	if (items < 3)
	    extra = NULL;
	else {
	    extra = INT2PTR(void *,SvIV(ST(2)));
	}

	RETVAL = purple_cipher_context_new_by_name(name, extra);
	ST(0) = purple_perl_bless_object(RETVAL, "Purple::Cipher::Context");

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_reset); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_reset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "context, extra = NULL");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	gpointer	extra;

	if (items < 2)
	    extra = NULL;
	else {
	    extra = purple_perl_ref_object(ST(1));
	}

	purple_cipher_context_reset(context, extra);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "context");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));

	purple_cipher_context_destroy(context);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_set_iv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_set_iv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "context, iv");
    {
	STRLEN	STRLEN_length_of_iv;
	size_t	XSauto_length_of_iv;
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	guchar *	iv = (guchar *)SvPV(ST(1), STRLEN_length_of_iv);

	XSauto_length_of_iv = STRLEN_length_of_iv;
	purple_cipher_context_set_iv(context, iv, XSauto_length_of_iv);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_append)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "context, data");
    {
	STRLEN	STRLEN_length_of_data;
	size_t	XSauto_length_of_data;
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	guchar *	data = (guchar *)SvPV(ST(1), STRLEN_length_of_data);

	XSauto_length_of_data = STRLEN_length_of_data;
	purple_cipher_context_append(context, data, XSauto_length_of_data);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_digest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_digest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "context, in_len, digest");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	size_t	in_len = (size_t)SvUV(ST(1));
	SV *	digest = ST(2);
#line 180 "Cipher.xs"
		gboolean ret;
		guchar *buff = NULL;
#line 543 "Cipher.c"
	size_t	RETVAL;
	dXSTARG;
#line 183 "Cipher.xs"
		SvUPGRADE(digest, SVt_PV);
		buff = (guchar *)SvGROW(digest, in_len);
		ret = purple_cipher_context_digest(context, in_len, buff, &RETVAL);
		if(!ret) {
			SvSetSV_nosteal(digest, &PL_sv_undef);
			XSRETURN_UNDEF;
		}
		SvCUR_set(digest, RETVAL);
		SvPOK_only(digest);
#line 556 "Cipher.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_digest_to_str); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_digest_to_str)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "context, in_len, digest_s");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	size_t	in_len = (size_t)SvUV(ST(1));
	SV *	digest_s = ST(2);
#line 201 "Cipher.xs"
		gboolean ret;
		gchar *buff = NULL;
#line 580 "Cipher.c"
	size_t	RETVAL;
	dXSTARG;
#line 204 "Cipher.xs"
		in_len += 1; /* perl shouldn't need to care about '\0' at the end */
		SvUPGRADE(digest_s, SVt_PV);
		buff = SvGROW(digest_s, in_len);
		ret = purple_cipher_context_digest_to_str(context, in_len, buff, &RETVAL);
		if(!ret) {
			SvSetSV_nosteal(digest_s, &PL_sv_undef);
			XSRETURN_UNDEF;
		}
		SvCUR_set(digest_s, RETVAL);
		SvPOK_only(digest_s);
#line 594 "Cipher.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_encrypt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_encrypt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "context, data_sv, output");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	SV *	data_sv = ST(1);
	SV *	output = ST(2);
#line 224 "Cipher.xs"
		size_t datalen;
		guchar *buff = NULL;
		guchar *data = NULL;
#line 619 "Cipher.c"
	gint	RETVAL;
	dXSTARG;
	size_t	outlen;
#line 228 "Cipher.xs"
		data = (guchar *)SvPV(data_sv, datalen);
		SvUPGRADE(output, SVt_PV);
		buff = (guchar *)SvGROW(output, datalen);
		RETVAL = purple_cipher_context_encrypt(context, data, datalen, buff, &outlen);
		if(outlen != 0) {
			SvPOK_only(output);
			SvCUR_set(output, outlen);
		} else {
			SvSetSV_nosteal(output, &PL_sv_undef);
		}
#line 634 "Cipher.c"
	XSprePUSH; PUSHi((IV)RETVAL);
	EXTEND(SP,1);
	PUSHs(sv_newmortal());
	sv_setuv(ST(1), (UV)outlen);
    }
    XSRETURN(2);
}


XS(XS_Purple__Cipher__Context_decrypt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_decrypt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "context, data_sv, output");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	SV *	data_sv = ST(1);
	SV *	output = ST(2);
#line 248 "Cipher.xs"
		size_t datalen;
		guchar *buff = NULL;
		guchar *data = NULL;
#line 662 "Cipher.c"
	gint	RETVAL;
	dXSTARG;
	size_t	outlen;
#line 252 "Cipher.xs"
		data = (guchar *)SvPV(data_sv, datalen);
		SvUPGRADE(output, SVt_PV);
		buff = (guchar *)SvGROW(output, datalen);
		RETVAL = purple_cipher_context_decrypt(context, data, datalen, buff, &outlen);
		if(outlen != 0) {
			SvPOK_only(output);
			SvCUR_set(output, outlen);
		} else {
			SvSetSV_nosteal(output, &PL_sv_undef);
		}
#line 677 "Cipher.c"
	XSprePUSH; PUSHi((IV)RETVAL);
	EXTEND(SP,1);
	PUSHs(sv_newmortal());
	sv_setuv(ST(1), (UV)outlen);
    }
    XSRETURN(2);
}


XS(XS_Purple__Cipher__Context_set_salt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_set_salt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "context, salt");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	guchar *	salt = (guchar *)SvPV_nolen(ST(1));

	purple_cipher_context_set_salt(context, salt);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_get_salt_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_get_salt_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "context");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	size_t	RETVAL;
	dXSTARG;

	RETVAL = purple_cipher_context_get_salt_size(context);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_set_key); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_set_key)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "context, key");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	guchar *	key = (guchar *)SvPV_nolen(ST(1));

	purple_cipher_context_set_key(context, key);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_get_key_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_get_key_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "context");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	size_t	RETVAL;
	dXSTARG;

	RETVAL = purple_cipher_context_get_key_size(context);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_set_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_set_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "context, data");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	gpointer	data = purple_perl_ref_object(ST(1));

	purple_cipher_context_set_data(context, data);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_get_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_get_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "context");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	gpointer	RETVAL;

	RETVAL = purple_cipher_context_get_data(context);
	ST(0) = purple_perl_bless_object(RETVAL, "gpointer");

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_get_batch_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_get_batch_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "context");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	Purple__Cipher__BatchMode	RETVAL;
	dXSTARG;

	RETVAL = purple_cipher_context_get_batch_mode(context);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_get_block_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_get_block_size)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "context");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	size_t	RETVAL;
	dXSTARG;

	RETVAL = purple_cipher_context_get_block_size(context);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Purple__Cipher__Context_set_batch_mode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_set_batch_mode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "context, mode");
    {
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	Purple__Cipher__BatchMode	mode = (Purple__Cipher__BatchMode)SvIV(ST(1));

	purple_cipher_context_set_batch_mode(context, mode);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Cipher__Context_set_key_with_len); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Cipher__Context_set_key_with_len)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "context, key");
    {
	STRLEN	STRLEN_length_of_key;
	size_t	XSauto_length_of_key;
	Purple__Cipher__Context	context = purple_perl_ref_object(ST(0));
	guchar *	key = (guchar *)SvPV(ST(1), STRLEN_length_of_key);

	XSauto_length_of_key = STRLEN_length_of_key;
	purple_cipher_context_set_key_with_len(context, key, XSauto_length_of_key);
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Purple__Cipher); /* prototype to pass -Wmissing-prototypes */
XS(boot_Purple__Cipher)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXSproto("Purple::Cipher::get_name", XS_Purple__Cipher_get_name, file, "$");
        newXSproto("Purple::Cipher::get_capabilities", XS_Purple__Cipher_get_capabilities, file, "$");
        newXSproto("Purple::Cipher::digest_region", XS_Purple__Cipher_digest_region, file, "$$$$");
        newXSproto("Purple::Cipher::http_digest_calculate_response", XS_Purple__Cipher_http_digest_calculate_response, file, "$$$$$$$$$");
        newXSproto("Purple::Cipher::http_digest_calculate_session_key", XS_Purple__Cipher_http_digest_calculate_session_key, file, "$$$$$$");
        newXSproto("Purple::Ciphers::find_cipher", XS_Purple__Ciphers_find_cipher, file, "$");
        newXSproto("Purple::Ciphers::register_cipher", XS_Purple__Ciphers_register_cipher, file, "$$");
        newXSproto("Purple::Ciphers::unregister_cipher", XS_Purple__Ciphers_unregister_cipher, file, "$");
        newXSproto("Purple::Ciphers::get_ciphers", XS_Purple__Ciphers_get_ciphers, file, "");
        newXSproto("Purple::Ciphers::get_handle", XS_Purple__Ciphers_get_handle, file, "");
        newXSproto("Purple::Cipher::Context::set_option", XS_Purple__Cipher__Context_set_option, file, "$$$");
        newXSproto("Purple::Cipher::Context::get_option", XS_Purple__Cipher__Context_get_option, file, "$$");
        newXSproto("Purple::Cipher::Context::new", XS_Purple__Cipher__Context_new, file, "$$;$");
        newXSproto("Purple::Cipher::Context::new_by_name", XS_Purple__Cipher__Context_new_by_name, file, "$$;$");
        newXSproto("Purple::Cipher::Context::reset", XS_Purple__Cipher__Context_reset, file, "$;$");
        newXSproto("Purple::Cipher::Context::destroy", XS_Purple__Cipher__Context_destroy, file, "$");
        newXSproto("Purple::Cipher::Context::set_iv", XS_Purple__Cipher__Context_set_iv, file, "$$");
        newXSproto("Purple::Cipher::Context::append", XS_Purple__Cipher__Context_append, file, "$$");
        newXSproto("Purple::Cipher::Context::digest", XS_Purple__Cipher__Context_digest, file, "$$$");
        newXSproto("Purple::Cipher::Context::digest_to_str", XS_Purple__Cipher__Context_digest_to_str, file, "$$$");
        newXSproto("Purple::Cipher::Context::encrypt", XS_Purple__Cipher__Context_encrypt, file, "$$$");
        newXSproto("Purple::Cipher::Context::decrypt", XS_Purple__Cipher__Context_decrypt, file, "$$$");
        newXSproto("Purple::Cipher::Context::set_salt", XS_Purple__Cipher__Context_set_salt, file, "$$");
        newXSproto("Purple::Cipher::Context::get_salt_size", XS_Purple__Cipher__Context_get_salt_size, file, "$");
        newXSproto("Purple::Cipher::Context::set_key", XS_Purple__Cipher__Context_set_key, file, "$$");
        newXSproto("Purple::Cipher::Context::get_key_size", XS_Purple__Cipher__Context_get_key_size, file, "$");
        newXSproto("Purple::Cipher::Context::set_data", XS_Purple__Cipher__Context_set_data, file, "$$");
        newXSproto("Purple::Cipher::Context::get_data", XS_Purple__Cipher__Context_get_data, file, "$");
        newXSproto("Purple::Cipher::Context::get_batch_mode", XS_Purple__Cipher__Context_get_batch_mode, file, "$");
        newXSproto("Purple::Cipher::Context::get_block_size", XS_Purple__Cipher__Context_get_block_size, file, "$");
        newXSproto("Purple::Cipher::Context::set_batch_mode", XS_Purple__Cipher__Context_set_batch_mode, file, "$$");
        newXSproto("Purple::Cipher::Context::set_key_with_len", XS_Purple__Cipher__Context_set_key_with_len, file, "$$");

    /* Initialisation Section */

#line 7 "Cipher.xs"
{
	HV *stash = gv_stashpv("Purple::Cipher::BatchMode", 1);
	HV *cipher_caps = gv_stashpv("Purple::Cipher::Caps", 1);

	static const constiv *civ, const_iv[] = {
#define const_iv(name) {#name, (IV)PURPLE_CIPHER_BATCH_MODE_##name}
		const_iv(ECB),
		const_iv(CBC),
#undef const_iv
	};

	static const constiv bm_const_iv[] = {
#define const_iv(name) {#name, (IV)PURPLE_CIPHER_CAPS_##name}
		const_iv(SET_OPT),
		const_iv(GET_OPT),
		const_iv(INIT),
		const_iv(RESET),
		const_iv(UNINIT),
		const_iv(SET_IV),
		const_iv(APPEND),
		const_iv(DIGEST),
		const_iv(ENCRYPT),
		const_iv(DECRYPT),
		const_iv(SET_SALT),
		const_iv(GET_SALT_SIZE),
		const_iv(SET_KEY),
		const_iv(GET_KEY_SIZE),
		const_iv(SET_BATCH_MODE),
		const_iv(GET_BATCH_MODE),
		const_iv(GET_BLOCK_SIZE),
		const_iv(SET_KEY_WITH_LEN),
		const_iv(UNKNOWN),
#undef const_iv
	};

	for (civ = const_iv + sizeof(const_iv) / sizeof(const_iv[0]); civ-- > const_iv; )
		newCONSTSUB(stash, (char *)civ->name, newSViv(civ->iv));

	for (civ = bm_const_iv + sizeof(bm_const_iv) / sizeof(bm_const_iv[0]); civ-- > bm_const_iv; )
		newCONSTSUB(cipher_caps, (char *)civ->name, newSViv(civ->iv));
}

#line 995 "Cipher.c"

    /* End of Initialisation Section */

    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

