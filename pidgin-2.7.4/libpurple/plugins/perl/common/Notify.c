/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of Notify.xs. Do not edit this file, edit Notify.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Notify.xs"
#include "module.h"

#line 13 "Notify.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 56 "Notify.c"

XS(XS_Purple__Notify_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_close)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "type, ui_handle");
    {
	Purple__NotifyType	type = (Purple__NotifyType)SvIV(ST(0));
	void *	ui_handle = INT2PTR(void *,SvIV(ST(1)));

	purple_notify_close(type, ui_handle);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Notify_close_with_handle); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_close_with_handle)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "handle");
    {
	void *	handle = INT2PTR(void *,SvIV(ST(0)));

	purple_notify_close_with_handle(handle);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__Notify_email); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_email)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "handle, subject, from, to, url, cb, user_data");
    {
	void *	handle = INT2PTR(void *,SvIV(ST(0)));
	const char *	subject = (const char *)SvPV_nolen(ST(1));
	const char *	from = (const char *)SvPV_nolen(ST(2));
	const char *	to = (const char *)SvPV_nolen(ST(3));
	const char *	url = (const char *)SvPV_nolen(ST(4));
	Purple__NotifyCloseCallback	cb = INT2PTR(Purple__NotifyCloseCallback,SvIV(ST(5)));
	gpointer	user_data = purple_perl_ref_object(ST(6));
	void *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_email(handle, subject, from, to, url, cb, user_data);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Purple__Notify_emails); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_emails)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 9)
       croak_xs_usage(cv,  "handle, count, detailed, subjects, froms, tos, urls, cb, user_data");
    {
	void *	handle = INT2PTR(void *,SvIV(ST(0)));
	size_t	count = (size_t)SvUV(ST(1));
	gboolean	detailed = (bool)SvTRUE(ST(2));
	const char **	subjects = INT2PTR(const char **,SvIV(ST(3)));
	const char **	froms = INT2PTR(const char **,SvIV(ST(4)));
	const char **	tos = INT2PTR(const char **,SvIV(ST(5)));
	const char **	urls = INT2PTR(const char **,SvIV(ST(6)));
	Purple__NotifyCloseCallback	cb = INT2PTR(Purple__NotifyCloseCallback,SvIV(ST(7)));
	gpointer	user_data = purple_perl_ref_object(ST(8));
	void *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_emails(handle, count, detailed, subjects, froms, tos, urls, cb, user_data);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Purple__Notify_formatted); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_formatted)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "handle, title, primary, secondary, text, cb, user_data");
    {
	void *	handle = INT2PTR(void *,SvIV(ST(0)));
	const char *	title = (const char *)SvPV_nolen(ST(1));
	const char *	primary = (const char *)SvPV_nolen(ST(2));
	const char *	secondary = (const char *)SvPV_nolen(ST(3));
	const char *	text = (const char *)SvPV_nolen(ST(4));
	Purple__NotifyCloseCallback	cb = INT2PTR(Purple__NotifyCloseCallback,SvIV(ST(5)));
	gpointer	user_data = purple_perl_ref_object(ST(6));
	void *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_formatted(handle, title, primary, secondary, text, cb, user_data);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Purple__Notify_userinfo); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_userinfo)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "gc, who, user_info, cb, user_data");
    {
	Purple__Connection	gc = purple_perl_ref_object(ST(0));
	const char *	who = (const char *)SvPV_nolen(ST(1));
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(2));
	Purple__NotifyCloseCallback	cb = INT2PTR(Purple__NotifyCloseCallback,SvIV(ST(3)));
	gpointer	user_data = purple_perl_ref_object(ST(4));
	void *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_userinfo(gc, who, user_info, cb, user_data);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Purple__Notify_message); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_message)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "handle, type, title, primary, secondary, cb, user_data");
    {
	void *	handle = INT2PTR(void *,SvIV(ST(0)));
	Purple__NotifyMsgType	type = (Purple__NotifyMsgType)SvIV(ST(1));
	const char *	title = (const char *)SvPV_nolen(ST(2));
	const char *	primary = (const char *)SvPV_nolen(ST(3));
	const char *	secondary = (const char *)SvPV_nolen(ST(4));
	Purple__NotifyCloseCallback	cb = INT2PTR(Purple__NotifyCloseCallback,SvIV(ST(5)));
	gpointer	user_data = purple_perl_ref_object(ST(6));
	void *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_message(handle, type, title, primary, secondary, cb, user_data);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Purple__Notify_searchresults); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_searchresults)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "gc, title, primary, secondary, results, cb, user_data");
    {
	Purple__Connection	gc = purple_perl_ref_object(ST(0));
	const char *	title = (const char *)SvPV_nolen(ST(1));
	const char *	primary = (const char *)SvPV_nolen(ST(2));
	const char *	secondary = (const char *)SvPV_nolen(ST(3));
	Purple__NotifySearchResults	results = purple_perl_ref_object(ST(4));
	Purple__NotifyCloseCallback	cb = INT2PTR(Purple__NotifyCloseCallback,SvIV(ST(5)));
	gpointer	user_data = purple_perl_ref_object(ST(6));
	void *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_searchresults(gc, title, primary, secondary, results, cb, user_data);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Purple__Notify_uri); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__Notify_uri)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "handle, uri");
    {
	void *	handle = INT2PTR(void *,SvIV(ST(0)));
	const char *	uri = (const char *)SvPV_nolen(ST(1));
	void *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_uri(handle, uri);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS(XS_Purple__NotifyUserInfo_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "class");
    {
	Purple__NotifyUserInfo	RETVAL;

	RETVAL = purple_notify_user_info_new(/* void */);
	ST(0) = purple_perl_bless_object(RETVAL, "Purple::NotifyUserInfo");

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Purple__NotifyUserInfo_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "user_info");
    {
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(0));

	purple_notify_user_info_destroy(user_info);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__NotifyUserInfo_get_entries); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_get_entries)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "user_info");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(0));
#line 136 "Notify.xs"
	GList *l;
#line 345 "Notify.c"
#line 138 "Notify.xs"
	l = purple_notify_user_info_get_entries(user_info);
	for (; l != NULL; l = l->next) {
		XPUSHs(sv_2mortal(purple_perl_bless_object(l->data, "Purple::NotifyUserInfoEntry")));
	}
#line 351 "Notify.c"
	PUTBACK;
	return;
    }
}


XS(XS_Purple__NotifyUserInfo_get_text_with_newline); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_get_text_with_newline)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "user_info, newline");
    {
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(0));
	const char *	newline = (const char *)SvPV_nolen(ST(1));
	gchar_own *	RETVAL;

	RETVAL = purple_notify_user_info_get_text_with_newline(user_info, newline);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
	 * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
	g_free (RETVAL);

    }
    XSRETURN(1);
}


XS(XS_Purple__NotifyUserInfo_add_pair); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_add_pair)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "user_info, label, value");
    {
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(0));
	const char *	label = (const char *)SvPV_nolen(ST(1));
	const char *	value = (const char *)SvPV_nolen(ST(2));

	purple_notify_user_info_add_pair(user_info, label, value);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__NotifyUserInfo_prepend_pair); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_prepend_pair)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "user_info, label, value");
    {
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(0));
	const char *	label = (const char *)SvPV_nolen(ST(1));
	const char *	value = (const char *)SvPV_nolen(ST(2));

	purple_notify_user_info_prepend_pair(user_info, label, value);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__NotifyUserInfo_add_section_break); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_add_section_break)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "user_info");
    {
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(0));

	purple_notify_user_info_add_section_break(user_info);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__NotifyUserInfo_add_section_header); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_add_section_header)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "user_info, label");
    {
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(0));
	const char *	label = (const char *)SvPV_nolen(ST(1));

	purple_notify_user_info_add_section_header(user_info, label);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__NotifyUserInfo_remove_last_item); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_remove_last_item)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "user_info");
    {
	Purple__NotifyUserInfo	user_info = purple_perl_ref_object(ST(0));

	purple_notify_user_info_remove_last_item(user_info);
    }
    XSRETURN_EMPTY;
}


XS(XS_Purple__NotifyUserInfo_entry_get_label); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_entry_get_label)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "user_info_entry");
    {
	Purple__NotifyUserInfoEntry	user_info_entry = purple_perl_ref_object(ST(0));
	const gchar *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_user_info_entry_get_label(user_info_entry);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Purple__NotifyUserInfo_entry_get_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_Purple__NotifyUserInfo_entry_get_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "user_info_entry");
    {
	Purple__NotifyUserInfoEntry	user_info_entry = purple_perl_ref_object(ST(0));
	const gchar *	RETVAL;
	dXSTARG;

	RETVAL = purple_notify_user_info_entry_get_value(user_info_entry);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Purple__Notify); /* prototype to pass -Wmissing-prototypes */
XS(boot_Purple__Notify)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXSproto("Purple::Notify::close", XS_Purple__Notify_close, file, "$$");
        newXSproto("Purple::Notify::close_with_handle", XS_Purple__Notify_close_with_handle, file, "$");
        newXSproto("Purple::Notify::email", XS_Purple__Notify_email, file, "$$$$$$$");
        newXSproto("Purple::Notify::emails", XS_Purple__Notify_emails, file, "$$$$$$$$$");
        newXSproto("Purple::Notify::formatted", XS_Purple__Notify_formatted, file, "$$$$$$$");
        newXSproto("Purple::Notify::userinfo", XS_Purple__Notify_userinfo, file, "$$$$$");
        newXSproto("Purple::Notify::message", XS_Purple__Notify_message, file, "$$$$$$$");
        newXSproto("Purple::Notify::searchresults", XS_Purple__Notify_searchresults, file, "$$$$$$$");
        newXSproto("Purple::Notify::uri", XS_Purple__Notify_uri, file, "$$");
        newXSproto("Purple::NotifyUserInfo::new", XS_Purple__NotifyUserInfo_new, file, "$");
        newXSproto("Purple::NotifyUserInfo::destroy", XS_Purple__NotifyUserInfo_destroy, file, "$");
        newXSproto("Purple::NotifyUserInfo::get_entries", XS_Purple__NotifyUserInfo_get_entries, file, "$");
        newXSproto("Purple::NotifyUserInfo::get_text_with_newline", XS_Purple__NotifyUserInfo_get_text_with_newline, file, "$$");
        newXSproto("Purple::NotifyUserInfo::add_pair", XS_Purple__NotifyUserInfo_add_pair, file, "$$$");
        newXSproto("Purple::NotifyUserInfo::prepend_pair", XS_Purple__NotifyUserInfo_prepend_pair, file, "$$$");
        newXSproto("Purple::NotifyUserInfo::add_section_break", XS_Purple__NotifyUserInfo_add_section_break, file, "$");
        newXSproto("Purple::NotifyUserInfo::add_section_header", XS_Purple__NotifyUserInfo_add_section_header, file, "$$");
        newXSproto("Purple::NotifyUserInfo::remove_last_item", XS_Purple__NotifyUserInfo_remove_last_item, file, "$");
        newXSproto("Purple::NotifyUserInfo::entry_get_label", XS_Purple__NotifyUserInfo_entry_get_label, file, "$");
        newXSproto("Purple::NotifyUserInfo::entry_get_value", XS_Purple__NotifyUserInfo_entry_get_value, file, "$");

    /* Initialisation Section */

#line 7 "Notify.xs"
{
	HV *type_stash = gv_stashpv("Purple::Notify::Type", 1);
	HV *msg_type_stash = gv_stashpv("Purple::Notify::Msg", 1);
	HV *user_info_stash = gv_stashpv("Purple::NotifyUserInfo::Type", 1);

	static const constiv *civ, type_const_iv[] = {
#define const_iv(name) {#name, (IV)PURPLE_NOTIFY_##name}
		const_iv(MESSAGE),
		const_iv(EMAIL),
		const_iv(EMAILS),
		const_iv(FORMATTED),
		const_iv(SEARCHRESULTS),
		const_iv(USERINFO),
		const_iv(URI),
	};
	static const constiv msg_type_const_iv[] = {
#undef const_iv
#define const_iv(name) {#name, (IV)PURPLE_NOTIFY_MSG_##name}
		const_iv(ERROR),
		const_iv(WARNING),
		const_iv(INFO),
	};
	static const constiv user_info_const_iv[] = {
#undef const_iv
#define const_iv(name) {#name, (IV)PURPLE_NOTIFY_USER_INFO_ENTRY_##name}
		const_iv(PAIR),
		const_iv(SECTION_BREAK),
		const_iv(SECTION_HEADER),
	};

	for (civ = type_const_iv + sizeof(type_const_iv) / sizeof(type_const_iv[0]); civ-- > type_const_iv; )
		newCONSTSUB(type_stash, (char *)civ->name, newSViv(civ->iv));

	for (civ = msg_type_const_iv + sizeof(msg_type_const_iv) / sizeof(msg_type_const_iv[0]); civ-- > msg_type_const_iv; )
		newCONSTSUB(msg_type_stash, (char *)civ->name, newSViv(civ->iv));

	for (civ = user_info_const_iv + sizeof(user_info_const_iv) / sizeof(user_info_const_iv[0]); civ-- > user_info_const_iv; )
		newCONSTSUB(user_info_stash, (char *)civ->name, newSViv(civ->iv));
}

#line 611 "Notify.c"

    /* End of Initialisation Section */

    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

